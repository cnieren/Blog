<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Chad Nierenhausen</title>
    <link>http://chadnierenhausen.com/tags/blog/</link>
    <description>Recent content in Blog on Chad Nierenhausen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Mar 2016 13:06:06 -0700</lastBuildDate>
    <atom:link href="http://chadnierenhausen.com/tags/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Big Changes</title>
      <link>http://chadnierenhausen.com/post/big-changes</link>
      <pubDate>Tue, 08 Mar 2016 13:06:06 -0700</pubDate>
      
      <guid>http://chadnierenhausen.com/post/big-changes</guid>
      <description>

&lt;p&gt;One of the main reasons I started this blog, was to give me a place that I could use an excuse to experiment with new things that I found interesting. True to that goal I have spent some time over that last week completely modifying the underlying structure and technologies that I use to author and host this blog. Here is a quick rundown of some of the changes.&lt;/p&gt;

&lt;h2 id=&#34;hugo:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;Hugo&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt; is another static site generator, much like Jekyll, but it runs on Go instead of Ruby. I have been interested in Go since it was announced in 2009 and have been looking for a reason to learn more about it ever since, so I decided to transition the blog to Hugo as a first step. The most recent release of Hugo (v0.15) includes a Jekyll site import utility which automates most of the conversion of existing posts from a Jekyll site to Hugo which cemented my decision to switch. Two other selling points for Hugo are that the Hugo command line utility runs on any operating system, as long as Go is installed and its &lt;a href=&#34;https://www.youtube.com/watch?v=CdiDYZ51a2o&#34; target=&#34;_blank&#34;&gt;really fast&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Editing the site now is a simple as running &lt;code&gt;hugo serve&lt;/code&gt; at the top level directory of the site. This builds the site, and launches a small webserver running on localhost:1313. It automatically watches the project directory and includes LiveReload plugin which automatically refreshes the browser when changes are saved. The site currently takes Hugo 23ms to build so changes are instantly visible in the browser after hitting save.&lt;/p&gt;

&lt;h2 id=&#34;theme:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;Theme&lt;/h2&gt;

&lt;p&gt;Hugo also has an impressive list of beautiful and free &lt;a href=&#34;http://themes.gohugo.io/&#34; target=&#34;_blank&#34;&gt;themes&lt;/a&gt; you can use to get up and running quickly. I decided that using the Jekyll importer and a pre-built theme would be too easy. So I decided to build my own theme in order to really learn how Hugo works and not just build my blog on a technology I don&amp;rsquo;t fully understand. I started by copying one of the existing themes, and modifying it to fit what I wanted, but ended up replacing most, if not all, of what I started with from the original theme. The decision to build my own theme did have its intended effect of forcing me to learn a significant amount about how Hugo works, and I feel much more comfortable digging into the innards of my site than I did when I was using Jekyll.&lt;/p&gt;

&lt;p&gt;The colors are all based on Ethan Schoonover&amp;rsquo;s &lt;a href=&#34;http://ethanschoonover.com/solarized&#34; target=&#34;_blank&#34;&gt;Solarized&lt;/a&gt; theme. I have spent an unhealthy amount of time getting this color scheme working on every terminal and code editor I use, so it seemed natural that I should spend even more time styling my blog with the same colors.&lt;/p&gt;

&lt;h2 id=&#34;codeship:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;Codeship&lt;/h2&gt;

&lt;p&gt;One of the benefits of using Jekyll was that GitHub Pages support it natively, you can read more about that &lt;a href=&#34;http://chadnierenhausen.com/post/about-this-blog---part-2#github:70e8f2fb385a2bc5383a41559af72e29&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;. If you are using GitHub Pages to serve a statically generated site, you need to have two branches that you manage for your site:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-code-fork&#34;&gt;&lt;/i&gt; master - contains the code for the generator and is where you would work on new content.&lt;/li&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-code-fork&#34;&gt;&lt;/i&gt; gh-pages - contains the static generated content that will be served by GitHub Pages.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This extra branch management, while not terrible, didn&amp;rsquo;t sound like a lot of fun, so I decided to use &lt;a href=&#34;https://codeship.com/&#34; target=&#34;_blank&#34;&gt;Codeship&lt;/a&gt;, a Continuous Delivery service, to handle the building and publishing steps for the blog. After creating an account with Codeship I setup a new Go project and configured the integration with GitHub. When Codeship notices a change in the GitHub repository it spins up a Docker container with Go installed, and pulls the code from GitHub into the container. Control is then handed over to the following test script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get -v github.com/spf13/hugo
hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All this script does is download the latest version of Hugo and build the site. If the build fails, Codeship aborts and alerts me that the build failed. If it builds successfully, then Codeship goes on to its deploy step. One of the built-in deployment options Codeship offers is Amazon S3.&lt;/p&gt;

&lt;h2 id=&#34;aws-s3:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;AWS S3&lt;/h2&gt;

&lt;p&gt;Amazon S3 buckets can easily be set up to host static web sites. After selecting a name for your bucket, you can select the option to &amp;lsquo;Enable website hosting&amp;rsquo; for the bucket then specify the index document, and error document. After setting the bucket up to host static content, provide Codeship with the needed information to access the bucket and it will automatically upload your generated site to the bucket when the build is successful.&lt;/p&gt;

&lt;p&gt;I now have the exact same workflow for publishing the blog &lt;code&gt;git push&lt;/code&gt;, but I am using Hugo, GitHub, Codeship and AWS instead of Jekyll, Vagrant, GitHub and Github Pages.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About this Blog - Part 2</title>
      <link>http://chadnierenhausen.com/post/about-this-blog---part-2</link>
      <pubDate>Wed, 02 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chadnierenhausen.com/post/about-this-blog---part-2</guid>
      <description>

&lt;h2 id=&#34;history:70e8f2fb385a2bc5383a41559af72e29&#34;&gt;History&lt;/h2&gt;

&lt;p&gt;Before I try to explain the concept of containers, let me start with a story of how we got to where we are now with server technology. Lets assume you have a data-driven website you want to deploy, you recently graduated college so you don&amp;rsquo;t have much money so you buy one moderately powerful computer run the database and webserver on the same machine. Not only is this a security vulnerability, it doesn&amp;rsquo;t allow you to scale up if you start to get more traffic than the one computer can handle. As your number of users grow you decide you need to upgrade your infrastructure so you buy another machine, the original runs your database and you move the webserver to the new computer. Now instead of the one machine you had running at an average of 75% resource utilization, you have two machines running at 30% each.&lt;/p&gt;

&lt;p&gt;Then one day someone posts one of your blogs on &lt;a href=&#34;http://slashdot.org/&#34; target=&#34;_blank&#34;&gt;SlashDot&lt;/a&gt; and the flood of users crashes your site. In a panic you buy 4 new computers one of them you make a secondary database and the other three are web servers this gets you back online, but after a few days the traffic to your site settles back down to the pre-SlashDot rate and you are now running 6 servers all at less than 10% resource utilization. Not ideal, but you should survive the next time a post hits the front page of SlashDot.&lt;/p&gt;

&lt;p&gt;Now that your site is internet famous you decide you should have an email address me@my-domain.com, you could install the email server on one of the new web servers you just purchased, but you know best practice is to only have one role installed per server and you don&amp;rsquo;t want to risk another crash so you can&amp;rsquo;t remove a web server. Your only option is to buy another computer to host your email... Or is it?&lt;/p&gt;

&lt;p&gt;This is where virtualization comes in, instead of buying a new moderately powerful computer for every service you want to run, buy a few really powerful computers and run separate virtual servers on that same set of hardware. Each virtual machine has its own operating system and is sandboxed off from the others so this isn&amp;rsquo;t a security vulnerability, and you can get more use out of the hardware that you buy. So you sell off your 6 old computers that were running your site and you buy 2 super powerful computers (virtual hosts) and build out your two databases, 4 web servers and your new email server as separate virtual machines, and now you are now more efficiently using your hardware.&lt;/p&gt;

&lt;p&gt;Could we do better? Every virtual machine that is running on your virtual hosts has to have its own operating system installed. In most cases every service is running the same operating system. That means a significant portion of your resource load is being used by the same processes all running on different installs of the same operating system. What if we only needed one operating system installed on our virtual hosts and we could run our applications in sandboxed containers inside of that one OS?&lt;/p&gt;

&lt;p&gt;This is where containers come in, now you buy your super powerful hardware, install one operating system on it, then package all of your services (web server, database, email server, etc.) into separate containers and run them on that one operating system. We are now using our hardware even more efficiently because we don&amp;rsquo;t have all those redundant operating systems doing the same thing across our virtual machines!&lt;/p&gt;

&lt;h2 id=&#34;docker:70e8f2fb385a2bc5383a41559af72e29&#34;&gt;Docker&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34;&gt;Docker&lt;/a&gt; containers wrap up a piece of software in a complete filesystem that contains everything it needs to run: code, runtime, system tools, system libraries - anything you can install on a server. This guarantees that it will always run the same, regardless of the environment it is running in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker is a utility that makes the configuration and management of containers a breeze. The actual technology that makes containers possible is split across a bunch of different libraries in the Linux kernel. Docker is and abstraction layer that sits on top of these libraries and presents a unified interface to create, manage and deploy application containers.&lt;/p&gt;

&lt;p&gt;For this site, I&amp;rsquo;m not using Docker to publish this site, but I am using it to develop this site. Jekyll runs on a Linux stack, and most of the machines that I work on run Windows. Instead of having to install Linux on all of the machines I want to write blog posts on I use the Jekyll Docker container. The Jekyll Docker container has all of the dependencies needed to build and render a Jekyll site, all I need to provide is the content.&lt;/p&gt;

&lt;p&gt;When I start the Jekyll Docker container I specify which directory contains my sites files, Docker maps this directory from my host machine to the Jekyll serve directory in the container. Once it&amp;rsquo;s up and running I can open the project in my favorite editor, point my browser to the web server running in the container and my workflow is no different than if everything was installed locally.&lt;/p&gt;

&lt;h2 id=&#34;github:70e8f2fb385a2bc5383a41559af72e29&#34;&gt;Github&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; is the largest code host on the planet with over 26.5 million repositories. Large or small, every repository comes with the same powerful tools. These tools are open to the community for public projects and secure for private projects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More specifically &lt;a href=&#34;https://pages.github.com/&#34; target=&#34;_blank&#34;&gt;GitHub Pages&lt;/a&gt; is where this blog is hosted. Every GitHub account has one GitHub Pages hosting account bundled with it. To use it, create a repository called username.github.io where username is your GitHub username. By default the site on the main branch of that repository will be hosted at username.github.io. Conveniently it will not only host static HTML sites, it knows how to host Jekyll sites as well. This means that when I want to publish a new post, all I have to do it check it into the main branch of the repository and it is automatically updated.&lt;/p&gt;

&lt;p&gt;You can also use a custom domain instead of username.github.io. All you have to do is add a file called CNAME to the root of your repository with the custom URL in it, and add a CNAME record to your DNS host with the same URL.&lt;/p&gt;

&lt;p&gt;Most of the technologies I have talked about in these two posts I have never used before. This simple blog has become a vehicle for me to learn many new technologies that I have been wanting to learn for a while, but never have had a project to use them with. I intend for this blog to continue to provide me with the drive to experiment and try out new things that I can&amp;rsquo;t justify using at work.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About this Blog - Part 1</title>
      <link>http://chadnierenhausen.com/post/about-this-blog---part-1</link>
      <pubDate>Thu, 18 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chadnierenhausen.com/post/about-this-blog---part-1</guid>
      <description>

&lt;h2 id=&#34;jekyll:6d39c835cfbcc75eac2b8c9d33749a9d&#34;&gt;Jekyll&lt;/h2&gt;

&lt;p&gt;About a year ago I learned about &lt;a href=&#34;http://www.staticgen.com/&#34; target=&#34;_blank&#34;&gt;Static Site Generators&lt;/a&gt;, systems that allow website developers to use templates, partials, data structures, and control flow statements to build websites, but don&amp;rsquo;t require a database backend. There is a build step that compiles all of the templates into simple HTML, CSS and JavaScript files. &lt;a href=&#34;http://octopress.org/&#34; target=&#34;_blank&#34;&gt;Octopress&lt;/a&gt; was the first generator that I got excited about, but by the time I got around to actually building this site Octopress was smack in the middle of moving to version 3.0, which is a backwards-compatibility breaking change and at the time of this writing there is no concrete release date.&lt;/p&gt;

&lt;p&gt;Octopress, before version 3.0, is really just a set of plugins and some custom modules built on top of &lt;a href=&#34;http://jekyllrb.com/&#34; target=&#34;_blank&#34;&gt;Jekyll&lt;/a&gt;, which is the second most popular static site generator, and the one that I chose to power this site. I ultimately decided to go with Jekyll because of its great documentation, tons of plugins, and a very active community. The biggest problem I had with Jekyll is that it runs on Ruby, and I develop mainly on Windows. While it is possible to get Ruby running on Windows, I really wasn&amp;rsquo;t interested in that fight. Additionally I wanted to be able to work on the blog from multiple machines without having to get a Ruby environment configured on each of them.&lt;/p&gt;

&lt;h2 id=&#34;vagrant:6d39c835cfbcc75eac2b8c9d33749a9d&#34;&gt;Vagrant&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.vagrantup.com/&#34; target=&#34;_blank&#34;&gt;Vagrant&lt;/a&gt; provides easy to configure, reproducible, and portable work environments built on top of industry-standard technology and controlled by a single consistent workflow to help maximize the productivity and flexibility of you and your team.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vagrant is essentially a virtual machine management utility, but unlike VirtualBox or V-Shpere, you define the operating system, and any dependencies or utilities you want to exist on the virtual machine in code. This makes it incredibly easy for teams to share development environments because the configuration of the machine is defined in file(s) that are checked into your version control system. When a new developer checks out the code repo the Vagrant file and any provisioning scripts are included. Then to get the virtual machine running to start development all you have to do is run &lt;code&gt;vagrant up&lt;/code&gt; and off you go. I don&amp;rsquo;t think this blog will ever have a team behind it, the ease of getting running on a different machine was the main draw for me.&lt;/p&gt;

&lt;p&gt;The first solution I came up with to skirt the issue with Ruby on Windows was to package Jekyll and all of its dependencies into an Ubuntu Vagrant box. It&amp;rsquo;s much simpler to set up a Ruby environment on Ubuntu, and I would only have to configure the environment once. The Vagrant file and the scripts to provision it could all be checked into a Git repository and shared across all the machines I want to develop on, and the only two tools I would need installed on the development machines are &lt;a href=&#34;https://www.virtualbox.org/&#34; target=&#34;_blank&#34;&gt;VirtualBox&lt;/a&gt; and Vagrant. There are a few gotcha&amp;rsquo;s when working with Jekyll in a Vagrant environment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;jekyll serve&lt;/code&gt; starts a webserver and hosts your site on 127.0.0.1:4000. This works great when your web browser is running on the same machine as Jekyll, but not when Jekyll is inside of a Vagrant box. To get around this issue you can either

&lt;ol&gt;
&lt;li&gt;Add the line &lt;code&gt;host: 0.0.0.0&lt;/code&gt; to your _config.yml, which holds all of your site specific configuration settings or,&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;jekyll serve -h 0.0.0.0&lt;/code&gt;, which has the same effect, but lets you opt in at runtime instead of being the default configuration. This would be useful if at some point I wanted to work on this site from a Linux machine directly and didn&amp;rsquo;t want to run Jekyll through a virtual machine.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;As of Jekyll version 2.4 the serve command will watch the file system of your site and when it detects a change it will automatically rebuild the site and a refresh of the browser will show you the result. This works great on a *nix system, but when you run Jekyll in Vagrant on Windows, NTFS doesn&amp;rsquo;t provide the same file update notifications. The work around for this is to run &lt;code&gt;jekyll serve --force_polling&lt;/code&gt; which will force the Jekyll server to periodically poll the file system and rebuild the site when it detects a change.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point we have Jekyll running inside of a Vagrant box, and all of the dependencies are hidden away inside of that container. The project is checked into a Git repository and any machine I want to develop on only needs to have Vagrant and VirtualBox installed. To work on the project all I need to do is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/cnieren/blag.git blag
cd blag
vagrant up
vagrant ssh
cd /site
jekyll serve --force_polling &amp;lt;-h 0.0.0.0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then point your browser to 0.0.0.0:4000 and you will see the generated result! Plus each time we make a change to a file and save it, the site is automatically rebuilt and a refresh of the browser window shows the changes.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>