<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jekyll on Chad Nierenhausen</title>
    <link>http://chadnierenhausen.com/tags/jekyll/</link>
    <description>Recent content in Jekyll on Chad Nierenhausen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Mar 2016 13:06:06 -0700</lastBuildDate>
    <atom:link href="http://chadnierenhausen.com/tags/jekyll/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Big Changes</title>
      <link>http://chadnierenhausen.com/post/big-changes</link>
      <pubDate>Tue, 08 Mar 2016 13:06:06 -0700</pubDate>
      
      <guid>http://chadnierenhausen.com/post/big-changes</guid>
      <description>

&lt;p&gt;One of the main reasons I started this blog, was to give me a place that I could use an excuse to experiment with new things that I found interesting. True to that goal I have spent some time over that last week completely modifying the underlying structure and technologies that I use to author and host this blog. Here is a quick rundown of some of the changes.&lt;/p&gt;

&lt;h2 id=&#34;hugo:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;Hugo&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt; is another static site generator, much like Jekyll, but it runs on Go instead of Ruby. I have been interested in Go since it was announced in 2009 and have been looking for a reason to learn more about it ever since, so I decided to transition the blog to Hugo as a first step. The most recent release of Hugo (v0.15) includes a Jekyll site import utility which automates most of the conversion of existing posts from a Jekyll site to Hugo which cemented my decision to switch. Two other selling points for Hugo are that the Hugo command line utility runs on any operating system, as long as Go is installed and its &lt;a href=&#34;https://www.youtube.com/watch?v=CdiDYZ51a2o&#34; target=&#34;_blank&#34;&gt;really fast&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Editing the site now is a simple as running &lt;code&gt;hugo serve&lt;/code&gt; at the top level directory of the site. This builds the site, and launches a small webserver running on localhost:1313. It automatically watches the project directory and includes LiveReload plugin which automatically refreshes the browser when changes are saved. The site currently takes Hugo 23ms to build so changes are instantly visible in the browser after hitting save.&lt;/p&gt;

&lt;h2 id=&#34;theme:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;Theme&lt;/h2&gt;

&lt;p&gt;Hugo also has an impressive list of beautiful and free &lt;a href=&#34;http://themes.gohugo.io/&#34; target=&#34;_blank&#34;&gt;themes&lt;/a&gt; you can use to get up and running quickly. I decided that using the Jekyll importer and a pre-built theme would be too easy. So I decided to build my own theme in order to really learn how Hugo works and not just build my blog on a technology I don&amp;rsquo;t fully understand. I started by copying one of the existing themes, and modifying it to fit what I wanted, but ended up replacing most, if not all, of what I started with from the original theme. The decision to build my own theme did have its intended effect of forcing me to learn a significant amount about how Hugo works, and I feel much more comfortable digging into the innards of my site than I did when I was using Jekyll.&lt;/p&gt;

&lt;p&gt;The colors are all based on Ethan Schoonover&amp;rsquo;s &lt;a href=&#34;http://ethanschoonover.com/solarized&#34; target=&#34;_blank&#34;&gt;Solarized&lt;/a&gt; theme. I have spent an unhealthy amount of time getting this color scheme working on every terminal and code editor I use, so it seemed natural that I should spend even more time styling my blog with the same colors.&lt;/p&gt;

&lt;h2 id=&#34;codeship:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;Codeship&lt;/h2&gt;

&lt;p&gt;One of the benefits of using Jekyll was that GitHub Pages support it natively, you can read more about that &lt;a href=&#34;http://chadnierenhausen.com/post/about-this-blog---part-2#github:70e8f2fb385a2bc5383a41559af72e29&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;. If you are using GitHub Pages to serve a statically generated site, you need to have two branches that you manage for your site:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-code-fork&#34;&gt;&lt;/i&gt; master - contains the code for the generator and is where you would work on new content.&lt;/li&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-code-fork&#34;&gt;&lt;/i&gt; gh-pages - contains the static generated content that will be served by GitHub Pages.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This extra branch management, while not terrible, didn&amp;rsquo;t sound like a lot of fun, so I decided to use &lt;a href=&#34;https://codeship.com/&#34; target=&#34;_blank&#34;&gt;Codeship&lt;/a&gt;, a Continuous Delivery service, to handle the building and publishing steps for the blog. After creating an account with Codeship I setup a new Go project and configured the integration with GitHub. When Codeship notices a change in the GitHub repository it spins up a Docker container with Go installed, and pulls the code from GitHub into the container. Control is then handed over to the following test script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get -v github.com/spf13/hugo
hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All this script does is download the latest version of Hugo and build the site. If the build fails, Codeship aborts and alerts me that the build failed. If it builds successfully, then Codeship goes on to its deploy step. One of the built-in deployment options Codeship offers is Amazon S3.&lt;/p&gt;

&lt;h2 id=&#34;aws-s3:ec751d1c87f43ffcfd2b468cb8a0be6a&#34;&gt;AWS S3&lt;/h2&gt;

&lt;p&gt;Amazon S3 buckets can easily be set up to host static web sites. After selecting a name for your bucket, you can select the option to &amp;lsquo;Enable website hosting&amp;rsquo; for the bucket then specify the index document, and error document. After setting the bucket up to host static content, provide Codeship with the needed information to access the bucket and it will automatically upload your generated site to the bucket when the build is successful.&lt;/p&gt;

&lt;p&gt;I now have the exact same workflow for publishing the blog &lt;code&gt;git push&lt;/code&gt;, but I am using Hugo, GitHub, Codeship and AWS instead of Jekyll, Vagrant, GitHub and Github Pages.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About this Blog - Part 1</title>
      <link>http://chadnierenhausen.com/post/about-this-blog---part-1</link>
      <pubDate>Thu, 18 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chadnierenhausen.com/post/about-this-blog---part-1</guid>
      <description>

&lt;h2 id=&#34;jekyll:6d39c835cfbcc75eac2b8c9d33749a9d&#34;&gt;Jekyll&lt;/h2&gt;

&lt;p&gt;About a year ago I learned about &lt;a href=&#34;http://www.staticgen.com/&#34; target=&#34;_blank&#34;&gt;Static Site Generators&lt;/a&gt;, systems that allow website developers to use templates, partials, data structures, and control flow statements to build websites, but don&amp;rsquo;t require a database backend. There is a build step that compiles all of the templates into simple HTML, CSS and JavaScript files. &lt;a href=&#34;http://octopress.org/&#34; target=&#34;_blank&#34;&gt;Octopress&lt;/a&gt; was the first generator that I got excited about, but by the time I got around to actually building this site Octopress was smack in the middle of moving to version 3.0, which is a backwards-compatibility breaking change and at the time of this writing there is no concrete release date.&lt;/p&gt;

&lt;p&gt;Octopress, before version 3.0, is really just a set of plugins and some custom modules built on top of &lt;a href=&#34;http://jekyllrb.com/&#34; target=&#34;_blank&#34;&gt;Jekyll&lt;/a&gt;, which is the second most popular static site generator, and the one that I chose to power this site. I ultimately decided to go with Jekyll because of its great documentation, tons of plugins, and a very active community. The biggest problem I had with Jekyll is that it runs on Ruby, and I develop mainly on Windows. While it is possible to get Ruby running on Windows, I really wasn&amp;rsquo;t interested in that fight. Additionally I wanted to be able to work on the blog from multiple machines without having to get a Ruby environment configured on each of them.&lt;/p&gt;

&lt;h2 id=&#34;vagrant:6d39c835cfbcc75eac2b8c9d33749a9d&#34;&gt;Vagrant&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.vagrantup.com/&#34; target=&#34;_blank&#34;&gt;Vagrant&lt;/a&gt; provides easy to configure, reproducible, and portable work environments built on top of industry-standard technology and controlled by a single consistent workflow to help maximize the productivity and flexibility of you and your team.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vagrant is essentially a virtual machine management utility, but unlike VirtualBox or V-Shpere, you define the operating system, and any dependencies or utilities you want to exist on the virtual machine in code. This makes it incredibly easy for teams to share development environments because the configuration of the machine is defined in file(s) that are checked into your version control system. When a new developer checks out the code repo the Vagrant file and any provisioning scripts are included. Then to get the virtual machine running to start development all you have to do is run &lt;code&gt;vagrant up&lt;/code&gt; and off you go. I don&amp;rsquo;t think this blog will ever have a team behind it, the ease of getting running on a different machine was the main draw for me.&lt;/p&gt;

&lt;p&gt;The first solution I came up with to skirt the issue with Ruby on Windows was to package Jekyll and all of its dependencies into an Ubuntu Vagrant box. It&amp;rsquo;s much simpler to set up a Ruby environment on Ubuntu, and I would only have to configure the environment once. The Vagrant file and the scripts to provision it could all be checked into a Git repository and shared across all the machines I want to develop on, and the only two tools I would need installed on the development machines are &lt;a href=&#34;https://www.virtualbox.org/&#34; target=&#34;_blank&#34;&gt;VirtualBox&lt;/a&gt; and Vagrant. There are a few gotcha&amp;rsquo;s when working with Jekyll in a Vagrant environment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;jekyll serve&lt;/code&gt; starts a webserver and hosts your site on 127.0.0.1:4000. This works great when your web browser is running on the same machine as Jekyll, but not when Jekyll is inside of a Vagrant box. To get around this issue you can either

&lt;ol&gt;
&lt;li&gt;Add the line &lt;code&gt;host: 0.0.0.0&lt;/code&gt; to your _config.yml, which holds all of your site specific configuration settings or,&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;jekyll serve -h 0.0.0.0&lt;/code&gt;, which has the same effect, but lets you opt in at runtime instead of being the default configuration. This would be useful if at some point I wanted to work on this site from a Linux machine directly and didn&amp;rsquo;t want to run Jekyll through a virtual machine.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;As of Jekyll version 2.4 the serve command will watch the file system of your site and when it detects a change it will automatically rebuild the site and a refresh of the browser will show you the result. This works great on a *nix system, but when you run Jekyll in Vagrant on Windows, NTFS doesn&amp;rsquo;t provide the same file update notifications. The work around for this is to run &lt;code&gt;jekyll serve --force_polling&lt;/code&gt; which will force the Jekyll server to periodically poll the file system and rebuild the site when it detects a change.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point we have Jekyll running inside of a Vagrant box, and all of the dependencies are hidden away inside of that container. The project is checked into a Git repository and any machine I want to develop on only needs to have Vagrant and VirtualBox installed. To work on the project all I need to do is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/cnieren/blag.git blag
cd blag
vagrant up
vagrant ssh
cd /site
jekyll serve --force_polling &amp;lt;-h 0.0.0.0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then point your browser to 0.0.0.0:4000 and you will see the generated result! Plus each time we make a change to a file and save it, the site is automatically rebuilt and a refresh of the browser window shows the changes.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>